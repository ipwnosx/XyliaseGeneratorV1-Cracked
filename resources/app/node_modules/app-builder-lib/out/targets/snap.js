"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebirdLst() {
  const data = require("bluebird-lst");

  _bluebirdLst = function () {
    return data;
  };

  return data;
}

function _builderUtil() {
  const data = require("builder-util");

  _builderUtil = function () {
    return data;
  };

  return data;
}

function _builderUtilRuntime() {
  const data = require("builder-util-runtime");

  _builderUtilRuntime = function () {
    return data;
  };

  return data;
}

function _fsExtraP() {
  const data = require("fs-extra-p");

  _fsExtraP = function () {
    return data;
  };

  return data;
}

function _jsYaml() {
  const data = require("js-yaml");

  _jsYaml = function () {
    return data;
  };

  return data;
}

var path = _interopRequireWildcard(require("path"));

function semver() {
  const data = _interopRequireWildcard(require("semver"));

  semver = function () {
    return data;
  };

  return data;
}

function _core() {
  const data = require("../core");

  _core = function () {
    return data;
  };

  return data;
}

function _linuxPackager() {
  const data = require("../linuxPackager");

  _linuxPackager = function () {
    return data;
  };

  return data;
}

function _pathManager() {
  const data = require("../util/pathManager");

  _pathManager = function () {
    return data;
  };

  return data;
}

function _targetUtil() {
  const data = require("./targetUtil");

  _targetUtil = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const defaultPlugs = ["desktop", "desktop-legacy", "home", "x11", "unity7", "browser-support", "network", "gsettings", "pulseaudio", "opengl"];

class SnapTarget extends _core().Target {
  constructor(name, packager, helper, outDir) {
    super(name);
    this.packager = packager;
    this.helper = helper;
    this.outDir = outDir;
    this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
    this.isUseTemplateApp = false;
  }

  replaceDefault(inList, defaultList) {
    const result = (0, _builderUtil().replaceDefault)(inList, defaultList);

    if (result !== defaultList) {
      this.isUseTemplateApp = false;
    }

    return result;
  }

  static getDefaultStagePackages() {
    // libxss1 - was "error while loading shared libraries: libXss.so.1" on Xubuntu 16.04
    // noinspection SpellCheckingInspection
    return ["libnspr4", "libnss3", "libxss1", "libappindicator3-1", "libsecret-1-0"];
  }

  createDescriptor(arch) {
    var _this = this;

    return (0, _bluebirdLst().coroutine)(function* () {
      if (!_this.isElectronVersionGreaterOrEqualThen("4.0.0")) {
        if (!_this.isElectronVersionGreaterOrEqualThen("2.0.0-beta.1")) {
          throw new (_builderUtil().InvalidConfigurationError)("Electron 2 and higher is required to build Snap");
        }

        _builderUtil().log.warn("Electron 4 and higher is highly recommended for Snap");
      }

      const appInfo = _this.packager.appInfo;

      const snapName = _this.packager.executableName.toLowerCase();

      const options = _this.options;
      const linuxArchName = (0, _linuxPackager().toAppImageOrSnapArch)(arch);
      const plugs = normalizePlugConfiguration(_this.options.plugs);

      const plugNames = _this.replaceDefault(plugs == null ? null : Object.getOwnPropertyNames(plugs), defaultPlugs);

      const buildPackages = (0, _builderUtilRuntime().asArray)(options.buildPackages);
      _this.isUseTemplateApp = _this.options.useTemplateApp !== false && arch === _builderUtil().Arch.x64 && buildPackages.length === 0;
      const appDescriptor = {
        command: "command.sh",
        plugs: plugNames,
        adapter: "none"
      };
      const snap = (0, _jsYaml().safeLoad)((yield (0, _fsExtraP().readFile)(path.join((0, _pathManager().getTemplatePath)("snap"), "snapcraft.yaml"), "utf-8")));

      if (_this.isUseTemplateApp) {
        delete appDescriptor.adapter;
      }

      if (options.grade != null) {
        snap.grade = options.grade;
      }

      if (options.confinement != null) {
        snap.confinement = options.confinement;
      }

      (0, _builderUtil().deepAssign)(snap, {
        name: snapName,
        version: appInfo.version,
        summary: options.summary || appInfo.productName,
        description: _this.helper.getDescription(options),
        architectures: [(0, _builderUtil().toLinuxArchString)(arch, true)],
        apps: {
          [snapName]: appDescriptor
        },
        parts: {
          app: {
            "stage-packages": _this.replaceDefault(options.stagePackages, SnapTarget.getDefaultStagePackages())
          }
        }
      });

      if (options.confinement === "classic") {
        delete appDescriptor.plugs;
        delete snap.plugs;
      } else {
        appDescriptor.environment = Object.assign({
          TMPDIR: "$XDG_RUNTIME_DIR",
          PATH: "$SNAP/usr/sbin:$SNAP/usr/bin:$SNAP/sbin:$SNAP/bin:$PATH",
          SNAP_DESKTOP_RUNTIME: "$SNAP/gnome-platform",
          LD_LIBRARY_PATH: ["$SNAP_LIBRARY_PATH", "$SNAP/lib:$SNAP/usr/lib:$SNAP/lib/" + linuxArchName + "-linux-gnu:$SNAP/usr/lib/" + linuxArchName + "-linux-gnu", "$LD_LIBRARY_PATH:$SNAP/lib:$SNAP/usr/lib", "$SNAP/lib/" + linuxArchName + "-linux-gnu:$SNAP/usr/lib/" + linuxArchName + "-linux-gnu"].join(":")
        }, options.environment);

        if (plugs != null) {
          for (const plugName of plugNames) {
            const plugOptions = plugs[plugName];

            if (plugOptions == null) {
              continue;
            }

            snap.plugs[plugName] = plugOptions;
          }
        }
      }

      if (buildPackages.length > 0) {
        snap.parts.app["build-packages"] = buildPackages;
      }

      if (options.after != null) {
        snap.parts.app.after = options.after;
      }

      if (options.assumes != null) {
        snap.assumes = (0, _builderUtilRuntime().asArray)(options.assumes);
      }

      return snap;
    })();
  }

  build(appOutDir, arch) {
    var _this2 = this;

    return (0, _bluebirdLst().coroutine)(function* () {
      const packager = _this2.packager;
      const options = _this2.options; // tslint:disable-next-line:no-invalid-template-strings

      const artifactName = packager.expandArtifactNamePattern(_this2.options, "snap", arch, "${name}_${version}_${arch}.${ext}", false);
      const artifactPath = path.join(_this2.outDir, artifactName);
      yield packager.info.callArtifactBuildStarted({
        targetPresentableName: "snap",
        file: artifactPath,
        arch
      });
      const snap = yield _this2.createDescriptor(arch);

      if (_this2.isUseTemplateApp) {
        delete snap.parts;
      }

      const stageDir = yield (0, _targetUtil().createStageDirPath)(_this2, packager, arch);
      const args = ["snap", "--app", appOutDir, "--stage", stageDir, "--arch", (0, _builderUtil().toLinuxArchString)(arch, true), "--output", artifactPath, "--executable", _this2.packager.executableName];
      yield _this2.helper.icons;

      if (_this2.helper.maxIconPath != null) {
        if (!_this2.isUseTemplateApp) {
          snap.icon = "snap/gui/icon.png";
        }

        args.push("--icon", _this2.helper.maxIconPath);
      } // snapcraft.yaml inside a snap directory


      const snapMetaDir = path.join(stageDir, _this2.isUseTemplateApp ? "meta" : "snap");
      const desktopFile = path.join(snapMetaDir, "gui", `${snap.name}.desktop`);
      yield _this2.helper.writeDesktopEntry(_this2.options, packager.executableName, desktopFile, {
        // tslint:disable:no-invalid-template-strings
        Icon: "${SNAP}/meta/gui/icon.png"
      });

      if (_this2.isElectronVersionGreaterOrEqualThen("5.0.0") && !isBrowserSandboxAllowed(snap)) {
        args.push("--extraAppArgs=--no-sandbox");

        if (_this2.isUseTemplateApp) {
          args.push("--exclude", "chrome-sandbox");
        }
      }

      if (packager.packagerOptions.effectiveOptionComputed != null && (yield packager.packagerOptions.effectiveOptionComputed({
        snap,
        desktopFile,
        args
      }))) {
        return;
      }

      yield (0, _fsExtraP().outputFile)(path.join(snapMetaDir, _this2.isUseTemplateApp ? "snap.yaml" : "snapcraft.yaml"), (0, _builderUtil().serializeToYaml)(snap));
      const hooksDir = yield packager.getResource(options.hooks, "snap-hooks");

      if (hooksDir != null) {
        args.push("--hooks", hooksDir);
      }

      if (_this2.isUseTemplateApp) {
        args.push("--template-url", "electron4");
      }

      yield (0, _builderUtil().executeAppBuilder)(args);
      yield packager.dispatchArtifactCreated(artifactPath, _this2, arch, packager.computeSafeArtifactName(artifactName, "snap", arch, false));
    })();
  }

  isElectronVersionGreaterOrEqualThen(version) {
    return semver().gte(this.packager.config.electronVersion || "5.0.3", version);
  }

}

exports.default = SnapTarget;

function normalizePlugConfiguration(raw) {
  if (raw == null) {
    return null;
  }

  const result = {};

  for (const item of Array.isArray(raw) ? raw : [raw]) {
    if (typeof item === "string") {
      result[item] = null;
    } else {
      Object.assign(result, item);
    }
  }

  return result;
}

function isBrowserSandboxAllowed(snap) {
  if (snap.plugs != null) {
    for (const plugName of Object.keys(snap.plugs)) {
      const plug = snap.plugs[plugName];

      if (plug.interface === "browser-support" && plug["allow-sandbox"] === true) {
        return true;
      }
    }
  }

  return false;
} 
// __ts-babel@6.0.4
//# sourceMappingURL=snap.js.map